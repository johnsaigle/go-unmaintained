# Dogfooding workflow - check our own dependencies
name: Self Check

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  schedule:
    # Run weekly on Monday morning
    - cron: '0 9 * * 1'
  workflow_dispatch:  # Allow manual triggering

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read

jobs:
  check-self:
    name: Check Own Dependencies
    runs-on: ubuntu-latest
    permissions:
      contents: read
      # Required for creating/updating issues on scheduled runs
      issues: write
      # Required for commenting on pull requests with dependency analysis
      pull-requests: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          persist-credentials: false
      
      - name: Set up Go
        uses: actions/setup-go@d35c59abb061a4a6fb18e82ac0862c26744d6ab5 # v5.5.0
        with:
          go-version: '>=1.21.0'
          cache: true
      
      - name: Download popular packages cache
        env:
          GH_TOKEN: ${{ secrets.PAT }}
        run: make download-cache
      
      - name: Build from source
        run: |
          echo "Building go-unmaintained from source..."
          make build
          echo "Built version:"
          ./bin/go-unmaintained --help | head -20
      
      - name: Check dependencies (JSON for processing)
        id: check
        env:
          PAT: ${{ secrets.PAT }}
        run: |
          set +e  # Don't exit on error
          
          echo "Running self-check with JSON output..."
          ./bin/go-unmaintained --json --no-exit-code > results.json
          
          # Parse results
          UNMAINTAINED=$(jq -r '.summary.UnmaintainedCount // 0' results.json)
          DIRECT=$(jq -r '.summary.DirectUnmaintained // 0' results.json)
          INDIRECT=$(jq -r '.summary.IndirectUnmaintained // 0' results.json)
          TOTAL=$(jq -r '.summary.TotalDependencies // 0' results.json)
          
          echo "unmaintained-count=$UNMAINTAINED" >> $GITHUB_OUTPUT
          echo "direct-count=$DIRECT" >> $GITHUB_OUTPUT
          echo "indirect-count=$INDIRECT" >> $GITHUB_OUTPUT
          echo "total-count=$TOTAL" >> $GITHUB_OUTPUT
          
          echo "ðŸ“Š Analysis complete:"
          echo "  Total dependencies: $TOTAL"
          echo "  Unmaintained: $UNMAINTAINED ($DIRECT direct, $INDIRECT indirect)"
      
      - name: Display detailed results
        env:
          PAT: ${{ secrets.PAT }}
        run: |
          echo ""
          echo "ðŸ” Detailed Analysis:"
          echo "===================="
          ./bin/go-unmaintained --verbose --check-outdated
      
      - name: Upload results artifact
        uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
        if: always()
        with:
          name: self-check-results
          path: results.json
          retention-days: 90
      
      - name: Comment on PR (if PR)
        if: github.event_name == 'pull_request' && steps.check.outputs.unmaintained-count > 0
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        env:
          UNMAINTAINED_COUNT: ${{ steps.check.outputs.unmaintained-count }}
          DIRECT_COUNT: ${{ steps.check.outputs.direct-count }}
          INDIRECT_COUNT: ${{ steps.check.outputs.indirect-count }}
        with:
          script: |
            const fs = require('fs');
            const results = JSON.parse(fs.readFileSync('./results.json', 'utf8'));
            const unmaintainedCount = parseInt(process.env.UNMAINTAINED_COUNT);
            const directCount = parseInt(process.env.DIRECT_COUNT);
            const indirectCount = parseInt(process.env.INDIRECT_COUNT);
            
            let comment = '## ðŸ” Self-Check: Unmaintained Dependencies\n\n';
            comment += `This PR affects a project that has **${unmaintainedCount}** unmaintained dependencies:\n`;
            comment += `- ðŸ”´ **${directCount}** direct dependencies\n`;
            comment += `- ðŸŸ¡ **${indirectCount}** indirect dependencies\n\n`;
            
            comment += '> âš ï¸ This is a self-check - go-unmaintained is analyzing its own dependencies!\n\n';
            
            // Group by direct/indirect
            const direct = results.results.filter(r => r.is_unmaintained && r.is_direct);
            const indirect = results.results.filter(r => r.is_unmaintained && !r.is_direct);
            
            if (direct.length > 0) {
              comment += '### ðŸ”´ Direct Dependencies\n\n';
              comment += '| Package | Issue | URL |\n';
              comment += '|---------|-------|-----|\n';
              for (const r of direct) {
                const url = r.repo_info?.url || 'N/A';
                comment += `| \`${r.package}\` | ${r.details} | [View](${url}) |\n`;
              }
              comment += '\n';
            }
            
            if (indirect.length > 0) {
              comment += '### ðŸŸ¡ Indirect Dependencies\n\n';
              comment += '| Package | Issue | Path |\n';
              comment += '|---------|-------|------|\n';
              for (const r of indirect) {
                const path = r.dependency_path?.join(' â†’ ') || 'N/A';
                comment += `| \`${r.package}\` | ${r.details} | ${path} |\n`;
              }
              comment += '\n';
            }
            
            comment += '---\n';
            comment += '*ðŸ• Dogfooding in action! This check was run by go-unmaintained on itself.*\n';
            
            github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: comment
            });
      
      - name: Create/Update issue (if scheduled and problems found)
        if: github.event_name == 'schedule' && steps.check.outputs.unmaintained-count > 0
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        env:
          UNMAINTAINED_COUNT: ${{ steps.check.outputs.unmaintained-count }}
          DIRECT_COUNT: ${{ steps.check.outputs.direct-count }}
          INDIRECT_COUNT: ${{ steps.check.outputs.indirect-count }}
          TOTAL_COUNT: ${{ steps.check.outputs.total-count }}
        with:
          script: |
            const fs = require('fs');
            const results = JSON.parse(fs.readFileSync('./results.json', 'utf8'));
            const unmaintainedCount = parseInt(process.env.UNMAINTAINED_COUNT);
            const directCount = parseInt(process.env.DIRECT_COUNT);
            const indirectCount = parseInt(process.env.INDIRECT_COUNT);
            const totalCount = parseInt(process.env.TOTAL_COUNT);
            
            // Check for existing issue
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'dependencies,self-check'
            });
            
            const existingIssue = issues.data.find(i => 
              i.title.includes('ðŸ• Self-Check: Unmaintained Dependencies')
            );
            
            let body = `# ðŸ• Dogfooding Report: Our Own Dependencies\n\n`;
            body += `**Check Date:** ${new Date().toISOString().split('T')[0]}\n\n`;
            body += `> ðŸ” This issue was created by running go-unmaintained on itself!\n\n`;
            body += `## Summary\n\n`;
            body += `- **Total Dependencies:** ${totalCount}\n`;
            body += `- **Unmaintained:** ${unmaintainedCount}\n`;
            body += `- **Direct:** ${directCount} ðŸ”´\n`;
            body += `- **Indirect:** ${indirectCount} ðŸŸ¡\n\n`;
            
            // Group by severity
            const archived = results.results.filter(r => r.is_unmaintained && r.reason === 'repository_archived');
            const notFound = results.results.filter(r => r.is_unmaintained && r.reason === 'package_not_found');
            const stale = results.results.filter(r => r.is_unmaintained && r.reason === 'stale_dependencies_inactive_repo');
            const outdated = results.results.filter(r => r.is_unmaintained && r.reason === 'outdated_version');
            
            if (archived.length > 0) {
              body += `## ðŸ“¦ Archived (${archived.length})\n\n`;
              for (const r of archived) {
                const type = r.is_direct ? 'ðŸ”´ Direct' : 'ðŸŸ¡ Indirect';
                const url = r.repo_info?.url || '';
                body += `- **${type}** [\`${r.package}\`](${url})\n`;
                if (r.dependency_path?.length > 0) {
                  body += `  - Path: ${r.dependency_path.join(' â†’ ')}\n`;
                }
              }
              body += '\n';
            }
            
            if (notFound.length > 0) {
              body += `## ðŸš« Not Found (${notFound.length})\n\n`;
              for (const r of notFound) {
                const type = r.is_direct ? 'ðŸ”´ Direct' : 'ðŸŸ¡ Indirect';
                body += `- **${type}** \`${r.package}\`\n`;
              }
              body += '\n';
            }
            
            if (stale.length > 0) {
              body += `## ðŸ’¤ Inactive (${stale.length})\n\n`;
              for (const r of stale) {
                const type = r.is_direct ? 'ðŸ”´ Direct' : 'ðŸŸ¡ Indirect';
                const days = r.repo_info?.last_commit_days || r.days_since_update;
                const url = r.repo_info?.url || '';
                body += `- **${type}** [\`${r.package}\`](${url}) - ${days} days\n`;
              }
              body += '\n';
            }
            
            if (outdated.length > 0) {
              body += `## ðŸ“… Outdated (${outdated.length})\n\n`;
              for (const r of outdated) {
                const type = r.is_direct ? 'ðŸ”´ Direct' : 'ðŸŸ¡ Indirect';
                body += `- **${type}** \`${r.package}\` - ${r.current_version} â†’ ${r.latest_version}\n`;
              }
              body += '\n';
            }
            
            body += `## ðŸ“‹ How to Fix\n\n`;
            body += `1. **Direct Dependencies:** Update in \`go.mod\`\n`;
            body += `   \`\`\`bash\n`;
            body += `   go get <package>@latest\n`;
            body += `   go mod tidy\n`;
            body += `   \`\`\`\n\n`;
            body += `2. **Indirect Dependencies:** Update parent packages\n`;
            body += `   \`\`\`bash\n`;
            body += `   go get -u ./...\n`;
            body += `   go mod tidy\n`;
            body += `   \`\`\`\n\n`;
            body += `3. **Archived Repos:** Find maintained alternatives\n\n`;
            body += `---\n`;
            body += `*ðŸ• Generated by self-check workflow. We practice what we preach!*\n`;
            
            if (existingIssue) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: existingIssue.number,
                body: `## ðŸ”„ Updated Report\n\n${body}`
              });
              console.log(`Updated issue #${existingIssue.number}`);
            } else {
              const issue = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: 'ðŸ• Self-Check: Unmaintained Dependencies Detected',
                body: body,
                labels: ['dependencies', 'self-check', 'automated']
              });
              console.log(`Created issue #${issue.data.number}`);
            }
      
      - name: Add status badge info
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        env:
          TOTAL_COUNT: ${{ steps.check.outputs.total-count }}
          UNMAINTAINED_COUNT: ${{ steps.check.outputs.unmaintained-count }}
        run: |
          echo "ðŸ“Š Self-Check Results:"
          echo "  Total: ${TOTAL_COUNT}"
          echo "  Unmaintained: ${UNMAINTAINED_COUNT}"
          echo ""
          echo "Badge URL: https://img.shields.io/badge/dependencies-${UNMAINTAINED_COUNT}%20unmaintained-orange"
      
      - name: Fail if critical issues (direct archived)
        if: steps.check.outputs.direct-count > 0
        env:
          DIRECT_COUNT: ${{ steps.check.outputs.direct-count }}
        run: |
          echo "::warning::Found ${DIRECT_COUNT} direct unmaintained dependencies"
          # Don't fail the workflow - just warn
          # Uncomment below to enforce strict checks:
          # exit 1
